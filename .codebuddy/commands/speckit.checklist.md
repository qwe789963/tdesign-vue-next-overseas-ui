---
description: 根据用户需求为当前功能生成自定义检查清单。
---

## 检查清单目的："需求的单元测试"

**核心概念**：检查清单是**需求编写的单元测试** - 它们验证给定领域中需求的质量、清晰度和完整性。

**不是用于验证/测试**：

- ❌ 不是 "验证按钮点击正确"
- ❌ 不是 "测试错误处理有效"
- ❌ 不是 "确认 API 返回 200"
- ❌ 不是检查代码/实现是否符合规格

**用于需求质量验证**：

- ✅ "是否为所有卡片类型定义了视觉层次需求？"（完整性）
- ✅ "'突出显示' 是否用具体的尺寸/定位进行了量化？"（清晰度）
- ✅ "所有交互元素的悬停状态需求是否一致？"（一致性）
- ✅ "是否为键盘导航定义了无障碍需求？"（覆盖范围）
- ✅ "规格是否定义了 logo 图片加载失败时的处理？"（边界情况）

**比喻**：如果你的规格是用英语编写的代码，检查清单就是它的单元测试套件。你正在测试需求是否编写良好、完整、无歧义且准备好实现 - 而不是测试实现是否有效。

## 用户输入

```text
$ARGUMENTS
```

在继续之前，你**必须**考虑用户输入（如果非空）。

## 执行步骤

1. **设置**：从仓库根目录运行前置条件检查脚本并解析 JSON 获取 FEATURE_DIR 和 AVAILABLE_DOCS 列表。
   - 所有文件路径必须是绝对路径。
   
   **首选 PowerShell**：
   ```powershell
   .specify/scripts/powershell/check-prerequisites.ps1 -Json
   ```
   
   **备用 Node.js**（当 PowerShell 脚本执行失败时使用）：
   ```bash
   node .specify/scripts/node/check-prerequisites.js --json
   ```
   
   - 对于参数中的单引号如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或尽可能使用双引号："I'm Groot"）。

2. **澄清意图（动态）**：推导最多三个初始上下文澄清问题（无预设目录）。它们必须：
   - 从用户的措辞 + 从 spec/plan/tasks 提取的信号生成
   - 仅询问会实质性改变检查清单内容的信息
   - 如果在 `$ARGUMENTS` 中已经明确，则单独跳过
   - 优先精确而非广度

3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清答案：
   - 推导检查清单主题（例如，安全、审查、部署、用户体验）
   - 整合用户提到的显式必备项
   - 将焦点选择映射到类别脚手架
   - 从 spec/plan/tasks 推断任何缺失的上下文（不要虚构）

4. **加载功能上下文**：从 FEATURE_DIR 读取：
   - spec.md：功能需求和范围
   - plan.md（如果存在）：技术细节、依赖
   - tasks.md（如果存在）：实现任务

5. **生成检查清单** - 创建"需求的单元测试"：
   - 如果不存在则创建 `FEATURE_DIR/checklists/` 目录
   - 生成唯一的检查清单文件名：
     - 根据领域使用简短、描述性的名称（例如，`ux.md`、`api.md`、`security.md`）
     - 格式：`[领域].md`
     - 如果文件存在，追加到现有文件
   - 从 CHK001 开始顺序编号项目
   - 每次 `/speckit.checklist` 运行创建一个新文件（从不覆盖现有检查清单）

   **核心原则 - 测试需求，而非实现**：
   每个检查清单项必须评估需求本身的：
   - **完整性**：是否存在所有必要的需求？
   - **清晰度**：需求是否无歧义且具体？
   - **一致性**：需求是否相互对齐？
   - **可测量性**：需求是否可以客观验证？
   - **覆盖范围**：是否涵盖所有场景/边界情况？

6. **报告**：输出创建的检查清单的完整路径、项目计数，并提醒用户每次运行都会创建新文件。总结：
   - 选择的焦点领域
   - 深度级别
   - 执行者/时机
   - 任何已纳入的用户指定的显式必备项

**重要**：每次 `/speckit.checklist` 命令调用都使用简短、描述性的名称创建检查清单文件，除非文件已存在。这允许：

- 不同类型的多个检查清单（例如，`ux.md`、`test.md`、`security.md`）
- 简单、易记的文件名，指示检查清单目的
- 在 `checklists/` 文件夹中轻松识别和导航

为避免混乱，使用描述性类型并在完成后清理过时的检查清单。
